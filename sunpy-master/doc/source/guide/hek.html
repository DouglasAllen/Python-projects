<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.10: http://docutils.sourceforge.net/" />
<title>Using SunPy's HEK module</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7514 2012-09-14 14:27:12Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="using-sunpy-s-hek-module">
<h1 class="title">Using SunPy's HEK module</h1>

<p>The Heliophysics Event Knowledgebase (HEK) is a repository of feature
and event information concerning the Sun.  Entries are generated both
by automated algorithms and human observers.  SunPy accesses this
information through the 'hek' module, which was developed through
support from the European Space Agency Summer of Code in Space
(ESA-SOCIS) 2011.</p>
<div class="section" id="setting-up-the-client">
<h1>1. Setting up the client</h1>
<p>SunPy's HEK module is in sunpy.net.  It can be imported into your
IPython session as follows:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; from sunpy.net import hek
&gt;&gt;&gt; client = hek.HEKClient()
</pre>
</blockquote>
<p>This creates a client that we will use to interact with the HEK.</p>
</div>
<div class="section" id="a-simple-query">
<h1>2. A simple query</h1>
<p>To search the HEK, you need a start time, an end time, and an event
type.  Times are specified as Python datetime objects.  Event types
are specified as upper case, two letter strings, and are identical to
the two letter abbreviations found at the HEK website,
<a class="reference external" href="http://www.lmsal.com/hek/VOEvent_Spec.html">http://www.lmsal.com/hek/VOEvent_Spec.html</a>.</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; tstart = '2011/08/09 07:23:56'
&gt;&gt;&gt; tend = '2011/08/09 12:40:29'
&gt;&gt;&gt; event_type = 'FL'
&gt;&gt;&gt; result = client.query(hek.attrs.Time(tstart,tend),hek.attrs.EventType(event_type))
</pre>
</blockquote>
<p>The first line in the block of code above imports the datetime module.
The second and third lines define the search start and end times.  The
fourth line specifies the event type, in this 'FL' or flare.  Line 5
goes out to the web, contacts the HEK, and queries it for the
information you have requested.  Event data for ALL flares available
in the HEK within the time range 2011/08/09 07:23: 56 UT - 2011/08/09
12:40:20 UT will be returned, regardless of which feature recognition
method used to detect the flare.</p>
<p>Let's break down the arguments of client.query.  The first argument:</p>
<blockquote>
hek.attrs.Time(tstart,tend)</blockquote>
<p>sets the start and end times for the query.  The second argument:</p>
<blockquote>
hek.attrs.EventType(event_type)</blockquote>
<p>sets the type of event to look for.  Since we have defined event_type
= 'FL', this sets the query to look for flares.  We could have also
set the flare event type using the syntax</p>
<blockquote>
hek.attrs.FL</blockquote>
<p>There is more on the attributes of hek.attrs in section 4 of this
guide.</p>
</div>
<div class="section" id="the-result">
<h1>3. The result</h1>
<p>So, how many flare detections did the query turn up?</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; len(result)
19
</pre>
</blockquote>
<p>The object returned by the above query is a list of Python dictionary
objects.  Each dictionary consists of key-value pairs that exactly
correspond to the parameters listed at
<a class="reference external" href="http://www.lmsal.com/hek/VOEvent_Spec.html">http://www.lmsal.com/hek/VOEvent_Spec.html</a>. You can inspect all the
dictionary keys very simply:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; result[0].keys()
[u'skel_startc1',
 u'concept',
 u'frm_versionnumber',
 u'hrc_coord',
 u'refs_orig',....
</pre>
</blockquote>
<p>and so on.  Remember, the HEK query we made returns all the flares in
the time-range stored in the HEK, regardless of the feature
recognition method.  The HEK parameter which stores the the feature
recognition method is called &quot;frm_name&quot;. Using list comprehensions
(which are very cool), it is easy to get a list of the feature
recognition methods used to find each of the flares in the result
object, for example:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; [elem[&quot;frm_name&quot;] for elem in result]
[u'asainz',
 u'asainz',
 u'asainz',
 u'asainz',
 u'asainz',
 u'asainz',
 u'asainz',
 u'SSW Latest Events',
 u'SEC standard',
 u'Flare Detective - Trigger Module',
 u'Flare Detective - Trigger Module',
 u'SSW Latest Events',
 u'SEC standard',
 u'Flare Detective - Trigger Module',
 u'Flare Detective - Trigger Module',
 u'Flare Detective - Trigger Module',
 u'Flare Detective - Trigger Module',
 u'Flare Detective - Trigger Module']
</pre>
</blockquote>
<p>It is likely each flare on the Sun was actually detected multiple
times by many different methods.</p>
</div>
<div class="section" id="more-complex-queries">
<h1>4. More complex queries</h1>
<p>The HEK client allows you to make more complex queries.  There are two
key features you need to know in order to make use of the full power
of the HEK client.  Firstly, the attribute module - hek.attrs -
describes ALL the parameters stored by the HEK as listed in
<a class="reference external" href="http://www.lmsal.com/hek/VOEvent_Spec.html">http://www.lmsal.com/hek/VOEvent_Spec.html</a>, and the HEK client makes
these parameters searchable.</p>
<p>To explain this, let's have a closer look at hek.attrs. The help
command is your friend here; scroll down to section DATA you will see:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; help(hek.attrs)
AR = &lt;sunpy.net.hek.attrs.AR object&gt;
Area = &lt;sunpy.net.hek.attrs.Area object&gt;
Bound = &lt;sunpy.net.hek.attrs.Bound object&gt;
BoundBox = &lt;sunpy.net.hek.attrs.BoundBox object&gt;
CC = &lt;sunpy.net.hek.attrs.CC object&gt;
CD = &lt;sunpy.net.hek.attrs.CD object&gt;
CE = &lt;sunpy.net.hek.attrs.CE object&gt;
CH = &lt;sunpy.net.hek.attrs.EventType object&gt;
CJ = &lt;sunpy.net.hek.attrs.EventType object&gt;
CR = &lt;sunpy.net.hek.attrs.EventType object&gt;
CW = &lt;sunpy.net.hek.attrs.EventType object&gt;
EF = &lt;sunpy.net.hek.attrs.EF object&gt;
ER = &lt;sunpy.net.hek.attrs.EventType object&gt;
Event = &lt;sunpy.net.hek.attrs.Event object&gt;
FA = &lt;sunpy.net.hek.attrs.EventType object&gt;
FE = &lt;sunpy.net.hek.attrs.EventType object&gt;
FI = &lt;sunpy.net.hek.attrs.FI object&gt;
FL = &lt;sunpy.net.hek.attrs.FL object&gt;
FRM = &lt;sunpy.net.hek.attrs.FRM object&gt;
etc etc...
</pre>
</blockquote>
<p>The object hek.attrs knows the attributes of the HEK.  You'll see that
one of the attributes is a flare object</p>
<blockquote>
FL = &lt;sunpy.net.hek.attrs.FL object&gt;</blockquote>
<p>We can replace hek.attrs.EventType('FL') with hek.attrs.FL - they do
the same thing, setting the query to look for flare events.  Both
methods of setting the event type are provided as a convenience</p>
<p>Let's look further at the FRM attribute:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; help(hek.attrs.FRM)
Help on FRM in module sunpy.net.hek.attrs object:
class FRM(__builtin__.object)
 |  Data descriptors defined here:
 |
 |  __dict__
 |      dictionary for instance variables (if defined)
 |
 |  __weakref__
 |      list of weak references to the object (if defined)
 |
 |  ----------------------------------------------------------------------
 |  Data and other attributes defined here:
 |
 |  Contact = &lt;sunpy.net.hek.attrs._StringParamAttrWrapper object&gt;
 |
 |  HumanFlag = &lt;sunpy.net.hek.attrs._StringParamAttrWrapper object&gt;
 |
 |  Identifier = &lt;sunpy.net.hek.attrs._StringParamAttrWrapper object&gt;
 |
 |  Institute = &lt;sunpy.net.hek.attrs._StringParamAttrWrapper object&gt;
 |
 |  Name = &lt;sunpy.net.hek.attrs._StringParamAttrWrapper object&gt;
 |
 |  ParamSet = &lt;sunpy.net.hek.attrs._StringParamAttrWrapper object&gt;
 |
 |  SpecificID = &lt;sunpy.net.hek.attrs._StringParamAttrWrapper object&gt;
 |
 |  URL = &lt;sunpy.net.hek.attrs._StringParamAttrWrapper object&gt;
 |
 |  VersionNumber = &lt;sunpy.net.hek.attrs._StringParamAttrWrapper object&gt;
</pre>
</blockquote>
<p>Let's say I am only interested in those flares identified by the SSW
Latest Events tool.  I can retrieve those entries only from the HEK
with the following command:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; result = client.query( hek.attrs.Time(tstart,tend), hek.attrs.EventType(event_type), hek.attrs.FRM.Name == 'SSW Latest Events')
&gt;&gt;&gt; len(result)
2
</pre>
</blockquote>
<p>We can also retrieve all the entries in the time range which were not
made by SSW Latest Events with the following command:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; result = client.query( hek.attrs.Time(tstart,tend), hek.attrs.EventType(event_type),hek.attrs.FRM.Name != 'SSW Latest Events')
&gt;&gt;&gt; len(result)
17
</pre>
</blockquote>
<p>We are using Python's comparison operators to filter the returns from
the HEK client.  Other comparisons are possible.  For example, let's
say I want all the flares that have a peak flux of over 4000.0:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; result = client.query(hek.attrs.Time(tstart,tend), hek.attrs.EventType(event_type), hek.attrs.FL.PeakFlux &gt; 4000.0)
&gt;&gt;&gt; len(result)
1
</pre>
</blockquote>
<p>Multiple comparisons can be included.  For example, let's say I want
all the flares with a peak flux above 1000 AND west of 800 arcseconds
from disk center of the Sun</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; result = client.query(hek.attrs.Time(tstart,tend), hek.attrs.EventType(event_type), hek.attrs.Event.Coord1 &gt; 800, hek.attrs.FL.PeakFlux &gt; 1000.0)
</pre>
</blockquote>
<p>Multiple comparison operators can be used to filter the results back
from the HEK.</p>
<p>The second important feature about the HEK client is that the
comparisons we've made above can be combined using Python's logical
operators.  This makes complex queries easy to create.  However, some
caution is advisable.  Let's say I want all the flares west of 50
arcseconds OR have a peak flux over 1000.0:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; result = client.query(hek.attrs.Time(tstart,tend), hek.attrs.EventType(event_type), (hek.attrs.Event.Coord1 &gt; 50) or (hek.attrs.FL.PeakFlux &gt; 1000.0) )
</pre>
</blockquote>
<p>and as a check</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; [elem[&quot;fl_peakflux&quot;] for elem in result]
[None,
None,
None,
None,
None,
None,
None,
2326.86,
1698.83,
None,
None,
2360.49,
3242.64,
1375.93,
6275.98,
923.984]
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; [elem[&quot;event_coord1&quot;] for elem in result]
[51,
51,
51,
924,
924,
924,
69,
883.2,
883.2,
69,
69,
883.2,
883.2,
883.2,
883.2,
883.2]
</pre>
</blockquote>
<p>Note that some of the fluxes are returned as &quot;None&quot;.  This is because
some feature recognition methods for flares do not report the peak
flux.  However, because the location of event_coord1 is greater than
50, the entry from the HEK for that flare detection is returned.</p>
<p>Let's say we want all the flares west of 50 arcseconds AND have a peak
flux over 1000.0:</p>
<blockquote>
<pre class="doctest-block">
&gt;&gt;&gt; result = client.query(hek.attrs.Time(tstart,tend), hek.attrs.EventType(event_type), (hek.attrs.Event.Coord1 &gt; 50) and (hek.attrs.FL.PeakFlux &gt; 1000.0) )
</pre>
<pre class="doctest-block">
&gt;&gt;&gt; [elem[&quot;fl_peakflux&quot;] for elem in result]
[2326.86, 1698.83, 2360.49, 3242.64, 1375.93, 6275.98]
&gt;&gt;&gt; [elem[&quot;event_coord1&quot;] for elem in result]
[883.2, 883.2, 883.2, 883.2, 883.2, 883.2]
</pre>
</blockquote>
<p>In this case none of the peak fluxes are returned with the value
&quot;None&quot;.  Since we are using an &quot;and&quot; logical operator we need a result
from the &quot;(hek.attrs.FL.PeakFlux &gt; 1000.0)&quot; filter.  Flares that have
&quot;None&quot; for a peak flux cannot provide this, and so are excluded.  The
&quot;None&quot; type in this context effectively means &quot;Don't know&quot;; in such
cases the client returns only those results from the HEK that
definitely satisfy the criteria passed to it.</p>
</div>
</div>
</body>
</html>
